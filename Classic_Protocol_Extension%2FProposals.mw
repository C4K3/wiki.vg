=Template=
Add your proposal at the end of the page. Please use [[Classic_Protocol_Extension#Extensions|existing extensions]] as your guide to formatting. Please sign your proposals and comments by ending it with <code><nowiki>~~~~</nowiki></code>.
<pre><nowiki>===ExtensionName===
:Proposed by ~~~~
:Brief summary of the extension.
:'''Motivation''': Explain why this is needed or how it is useful.
:'''Client Behavior''': Detailed description of all new behavior that game clients need to implement in order to support this extension. Consider interaction with other extensions.
:'''Server Behavior''': Detailed description of all new behavior that game servers need to implement in order to support this extension. Consider interaction with other extensions.
:(Packet definitions, remarks, illustrations, and data tables go here)
:(Comments go here, please sign them)
</nowiki></pre>
=Proposals=
===PlaySound===
:Proposed by !!!WARLOCK!!!
:This extension allows server to play custom sound and musics on client.
:'''Motivation''': Servers can play custom musics or sound effects just in time or when something changes. Useful for gamemodes such as zombie survival, Servers can play zombie moaning sound while zombies are close to players. Player join and leave sounds, Kill streak sounds for games such as CTF, Radio and DJ class for players and sound effects for explosions and player deaths.
:'''Client Behavior''': Client must download and load, or load the sound directly from the URL with the ID. Client must be able to download any time after MapFinalize has sent. If the URL is empty then the Client must unload the sound with that ID. Client must unload the sound and load a new one if there's a sound with existing ID. Client must be able to play the sound right after receiving the PlaySound packet. The last playing sound can not be ignored or stopped when a new sound is going to be played. Files type must be in .WAV, otherwise they're ignored. Client must ignore downloading the existing files from Server if they're saved in drive. Client must not change the volume of all environments (Place/Destroy, Walk sounds) on SetVolume packet. Client must change a local variable for volume of next playing sound on SetVolume packet.
:'''Server Behavior''': Server must ignore sending the same url multiple times. Server can not send quick loops of sound due to network speed and client crash possibility. It's better to load all of required sounds after map load for better performance. Server must not send high sized file cause of time and speed it takes for download. Files type must be in .WAV, otherwise they're ignored. Server can change the volume before playing a sound. For a better networking, It's suggested to not send PlaySound instead of changing volume to zero.
:<h4>LoadSound packet</h4>
:''Server to client''
:{| class="wikitable"
|- class="row0"
! class="col0" | Packet ID
! class="col1" | Field Name
! class="col2" | Field Type
! class="col3" | Example
! class="col4" | Notes
|- class="row1"
| class="col0 centeralign" rowspan="3" | 0x??
(??)
| class="col1 centeralign" | ID
| class="col2 centeralign" | byte
| class="col3 centeralign" | 143
| class="col4 centeralign" | Gives the URL an ID.
|- class="row2"
| class="col1 centeralign" | URL
| class="col2 centeralign" | string
| class="col3 centeralign" | http://site.com/firstblood.wav
| class="col4 centeralign" | Address to a .WAV file, put this empty for unload.
|- class="row3"
! class="col0" | Total Size:
| class="col1 rightalign" colspan="4" | 66 bytes
|}
:<h4>PlaySound packet</h4>
:''Server to client''
:{| class="wikitable"
|- class="row0"
! class="col0" | Packet ID
! class="col1" | Field Name
! class="col2" | Field Type
! class="col3" | Example
! class="col4" | Notes
|- class="row1"
| class="col0 centeralign" rowspan="3" | 0x??
(??)
| class="col1 centeralign" | ID
| class="col2 centeralign" | byte
| class="col3 centeralign" | 125
| class="col4 centeralign" | Plays the sound saved as ID.
|- class="row2"
! class="col0" | Total Size:
| class="col1 rightalign" colspan="4" | 2 bytes
|}
:<h4>SetVolume packet</h4>
:''Server to client''
:{| class="wikitable"
|- class="row0"
! class="col0" | Packet ID
! class="col1" | Field Name
! class="col2" | Field Type
! class="col3" | Example
! class="col4" | Notes
|- class="row1"
| class="col0 centeralign" rowspan="3" | 0x??
(??)
| class="col1 centeralign" | Percent
| class="col2 centeralign" | byte
| class="col3 centeralign" | 87
| class="col4 centeralign" | Set the next playing sound(s) volume to a Percentage.
|- class="row2"
! class="col0" | Total Size:
| class="col1 rightalign" colspan="4" | 2 bytes
|}

===ClientRedirection===
:Proposed by [[User:Sysr q|Sysr q]] ([[User talk:Sysr q|talk]]) 10:17, 12 May 2014 (UTC)
:This extension allows servers to give clients a ''redirection'' to a separate, possibly "private" server.
:'''Motivation''': Allowing servers to redirect clients would be useful in several cases. Allowing a singular "hub" server to redirect players to various external (but related) servers depending on the gamemode they wish to play would allow tightly integrated networks. If servers are using an external "balancer" or some sort of Minecraft-aware proxy, the server could signal the proxy move its connection on the client's behalf to another server.
:'''Client Behavior''': Clients should be ready to receive a '''''ClientRedirection''''' packet any time after they receive a '''''LevelFinalize''''' packet. When clients receive a '''''ClientRedirection''''' packet, they should prompt the user with a message indicating the server they're being redirected too, and allow the user to continue or quit. Non-player clients (e.g., proxies) have the option of silently reconnecting on the client's behalf. Clients should then open a new connection to the newly redirected server, and begin standard negotiation protocol.
:'''Server Behavior''': Servers should only send a '''''ClientRedirection''''' packet after the they have sent a '''''LevelFinalize''''' packet. They should ensure the new server the client is being redirected to exists, and preferably is online and available.
:<h4>ClientRedirection packet</h4>
:''Server to client''
:{| class="wikitable"
|- class="row0"
! class="col0" | Packet ID
! class="col1" | Field Name
! class="col2" | Field Type
! class="col3" | Example
! class="col4" | Notes
|- class="row1"
| class="col0 centeralign" rowspan="3" | 0x??
(??)
| class="col1 centeralign" | Address
| class="col2 centeralign" | string
| class="col3 centeralign" | mc.example.org
| class="col4 centeralign" | Can be an IP address (IPv4/IPv6) or a hostname.
|- class="row2"
| class="col1 centeralign" | Port
| class="col2 centeralign" | int
| class="col3 centeralign" | 25565
| class="col4 centeralign" |
|- class="row3"
| class="col1 centeralign" | Name
| class="col2 centeralign" | string
| class="col3 centeralign" | Joe Blogg's Freebuild
| class="col4 centeralign" | ''(optional)'' User-friendly name to be displayed in user prompt.
|- class="row4"
! class="col0" | Total Size:
| class="col1 rightalign" colspan="4" | 133 bytes
|}

===PlayerClick===
:Proposed by umby24
:This extension is used to alert server owners that a player has clicked on something.
:'''Motivation''': The motivation for this extension is to allow for the creation of more interactive maps.
:'''Client Behavior''': Whenever a client clicks on something (right, middle or left click) the client should send a PlayerClicked packet to the server.
:'''Server Behavior''': Server should be ready to accept PlayerClicked packet at any time after level sending has completed. At which point, handling of this packet is entirely up to the server developer.
<h4>PlayerClicked packet</h4>
:''Client to Server''
:{| class="wikitable"
|- class="row0"
! class="col0" | Packet ID
! class="col1" | Field Name
! class="col2" | Field Type
! class="col3" | Example
! class="col4" | Notes
|- class="row1"
| class="col0 centeralign" rowspan="3" | 0x??
(??)
| class="col1 centeralign" | Button
| class="col2 centeralign" | byte
| class="col3 centeralign" | 0
| class="col4 centeralign" | 0 = Left click, 1 = Middle click, 2 = Right Click
|- class="row2"
! class="col0" | Total Size:
| class="col1 rightalign" colspan="4" | 2 bytes
|}
:(Comments go here, please sign them)

===CustomWorld===
:Proposed by Rayne
:This extension is used to customize the world by allowing the server to assign different textures to mobs and blocks
:'''Motivation''': The motivation for this extension is to allow the server to create their own custom mobs and blocks without needing to modify the client. This means hosts could improve their minigames by adding skins to easily recognize the two different teams and creating skins to represent different entities in a role-playing server.
:'''Client Behavior''': The client must receive the URL of the skin and the entity to assign it to, to be ready to download the resource and give the skin to the entity. If the resource isn't found nothing else happens
:'''Server Behavior''': The server should send a '''valid''' URL which locates the source and the ID of the entity to assign the skin to.
<h4>SetSkin packet</h4>
:''Client to Server''
:{| class="wikitable"
|- class="row0"
! class="col0" | Packet ID
! class="col1" | Field Name
! class="col2" | Field Type
! class="col3" | Example
! class="col4" | Notes
|- class="row1"
| class="col0 centeralign" rowspan="3" | 0x??
(??)
| class="col1 centeralign" | EntityID
| class="col2 centeralign" | byte
| class="col3 centeralign" | 0
| class="col4 centeralign" | The id of the entity
|- class="row2"
| class="col1 centeralign" | SkinURL
| class="col2 centeralign" | string
| class="col3 centeralign" | "http://www.example.com/image.png"
| class="col4 centeralign" | The URL to download the resource from
|- class="row3"
! class="col0" | Total Size:
| class="col1 rightalign" colspan="4" | 66 bytes
|}
===Custom Blocks v2===
:Proposed by Rayne
:This extension gives support for extra blocks 
:'''Motivation''': The motivation of this extension is to give the server a use of "extra building material". For example extra wool for a pixel art, or an medieval themed map which both classic/cpe blocks and extra blocks
:'''Client Behavior''': First of all the client sends the CustomBlocks packet with support level 2. Then the client will define block all possible block ids and link them to a position to the terrain.png (Preferably the id + 1). 
:'''Server Behavior''': The server will receive the custom blocks packet version 2 and start allowing use of the extra blocks. The textures of these blocks can be changed by simply using the EnvSetMapAppearance packet.
:No new packets are defined
===LongerMessages===
:Proposed by [[User:F|F]] ([[User talk:F|talk]]) 21:43, 28 August 2014 (UTC)
:This extension allows clients to accept messages longer than 64 characters, and send them to the server in parts.
:'''Motivation''': To allow players to write longer messages!
:'''Client Behavior''': When a regular-length message is sent, a single [[Classic_Protocol#Server_.E2.86.92_Client_packets|'''''Message''''']] packet is sent, with the unused ''PlayerID'' (aka ''MessageType'') byte set to <code>0</code>. When an extra-long message is sent, multiple [[Classic_Protocol#Server_.E2.86.92_Client_packets|'''''Message''''']] packets are sent. All packets except the last one should have the unused byte set to <code>1</code>, meaning "this message continues in the next Message packet".
:'''Server Behavior''': Server should check the unused ''PlayerID'' (aka ''MessageType'') byte of every incoming [[Classic_Protocol#Server_.E2.86.92_Client_packets|'''''Message''''']] packet. If the value is non-zero, it should treat it as a partial message. Partial messages should be stored and prepended to the next message received from this player, until a message with a <code>0</code> byte is received.
:No new packets are defined, but treatment of [[Classic_Protocol#Server_.E2.86.92_Client_packets|'''''Message''''']] packet is altered.
===ColorCodeControl===
:Proposed by [[User:F|F]] ([[User talk:F|talk]]) 22:00, 28 August 2014 (UTC)
:Gives servers an option to allow players to type in color codes, and a way to render <code>&</code> character in chat.
:'''Motivation''': Allow players to type in color codes and to use & in chat.
:'''Client Behavior''': When this extension is mutually supported, treat character sequence <code>&&</code> as meaning "draw an <code>&</code> character", without modifying current color. Do not allow <code>&</code> to be typed or pasted into chat unless '''''ColorCodeControl''''' packet has been received with ''AllowColorCodes'' set to <code>1</code>.
:'''Server Behavior''': When this extension is mutually supported, server may send '''''ColorCodeControl''''' packet to allow client to type or paste color codes. Server should treat <code>&&</code> as described above.
<h4>ColorCodeControl packet</h4>
:''Server to Client''
:{| class="wikitable"
|- class="row0"
! class="col0" | Packet ID
! class="col1" | Field Name
! class="col2" | Field Type
! class="col3" | Example
! class="col4" | Notes
|- class="row1"
| class="col0 centeralign" | ??
| class="col1 centeralign" | AllowColorCodes
| class="col2 centeralign" | byte
| class="col3 centeralign" | 0
| class="col4 centeralign" | 0 = disallow
1 = allow
|- class="row2"
! class="col0" | Total Size:
| class="col1 rightalign" colspan="4" | 2 bytes
|}
===UnicodeChat===
:Proposed by [[User:F|F]] ([[User talk:F|talk]]) 22:48, 28 August 2014 (UTC)
:Expands character encoding beyond ASCII. There are three ways to go about this:
:* Expand charset to 256 characters using Latin1 or Win-1252.
:** '''Pro''': Easiest to implement in clients (few changes to FontRenderer needed) and servers (no multibyte character support needed).
:** '''Pro''': No new packets needed.
:** '''Pro''': Easy to create custom fonts.
:** '''Pro''': Low resource use (low RAM and VRAM use, no additional CPU use, small font file).
:** '''Con''': Still only 256 characters.
:* Expand charset to Unicode [http://en.wikipedia.org/wiki/Basic_Multilingual_Plane#Basic_Multilingual_Plane|Basic Multilingual Plane] (BMP) with UCS-2 fixed-length encoding.
:** '''Pro''': Lots of characters (~65k) covering most languages and symbols.
:** '''Pro''': Not too hard to implement (characters still fixed-width, native support in Java and C#).
:** '''Pro''': Free fonts available that covers all characters.
:** '''Con''': New renderer (possibly third-party library) needed for rendering.
:** '''Con''': Higher resource use (higher RAM and VRAM use, more CPU use, large font file).
:** '''Con''': Very hard to create custom fonts.
:** '''Con''': Still does not cover all characters.
:* Expand charset to full Unicode with UTF-8 encoding. Includes all the supplemental Unicode planes.
:** '''Pro''': Theoretically covers all languages and symbols.
:** '''Con''': Does not ''actually'' cover all languages and symbols due to non-existence of 100% fonts.
:** '''Con''': Hard to find free fonts that extend beyond the BMP.
:** '''Con''': Harder to work with strings (due to variable-width characters).
:** '''Con''': Third-party library needed for rendering.
:** '''Con''': Highest resource use (highest RAM and VRAM use, most CPU use, largest font files).
:** '''Con''': Harder to implement (no native support in WinAPI / Java / C#).
