All data sent over the network is [http://en.wikipedia.org/wiki/Endianness#Big-endian big-endian], that is the bytes are sent from most significant byte to least significant byte. The majority of everyday computers are little-endian, therefore it may be necessary to change the endianness before sending data over the network.

Other than 'String' and 'Metadata', which are decoded with a custom function, these data formats are identical to those provided by the Java classes [http://download.oracle.com/javase/1.4.2/docs/api/java/io/DataInputStream.html DataInputStream] and [http://download.oracle.com/javase/1.4.2/docs/api/java/io/DataOutputStream.html DataOutputStream].

{| class="wikitable"
|- class="row0"
| class="col0" |
! class="col1" | Size
! class="col2" | Range
! class="col3" | Notes
|- class="row1"
! class="col0 centeralign" | bool
| class="col1 centeralign" | 1
| class="col2" | 0 or 1
| class="col3" | Value can be either true (0x01) or false (0x00)
|- class="row2"
! class="col0 centeralign" | byte
| class="col1 centeralign" | 1
| class="col2" | -128 to 127
| class="col3" | Signed, two's complement
|- class="row3"
! class="col0 centeralign" | short
| class="col1 centeralign" | 2
| class="col2" | -32768 to 32767
| class="col3" | Signed, two's complement
|- class="row4"
! class="col0 centeralign" | int
| class="col1 centeralign" | 4
| class="col2" | -2147483648 to 2147483647
| class="col3" | Signed, two's complement
|- class="row5"
! class="col0 centeralign" | long
| class="col1 centeralign" | 8
| class="col2" | -9223372036854775808 to 9223372036854775807
| class="col3" | Signed, two's complement
|- class="row8"
! class="col0 centeralign" | 128-bit integer
| class="col1 centeralign" | 16
| class="col2" | 0 to 340282366920938463463374607431768211455
| class="col3" | Unsigned, two's complement

Used in [http://wiki.vg/Protocol#Spawn_Global_Entity 0x2C] to transmit UUIDs.

The vanilla Minecraft server internally sends this as two longs.
|- class="row7"
! class="col0 centeralign" | float
| class="col1 centeralign" | 4
| class="col2" |
See [http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.2.3 this]
| class="col3" | Single-precision 32-bit IEEE 754 floating point
|- class="row8"
! class="col0 centeralign" | double
| class="col1 centeralign" | 8
| class="col2" |
See [http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.2.3 this]
| class="col3" | Double-precision 64-bit IEEE 754 floating point
|- class="row9"
! class="col0 centeralign" | string
| class="col1 centeralign" | ≥ 2 <br />≤ 240
| class="col2" | N/A
| class="col3" | UTF-8 String length prefixed with a VarInt
|- 
! class="centeralign" | VarInt
| class="centeralign" | Varies
| [http://developers.google.com/protocol-buffers/docs/encoding#varints Protocol Buffer 32-bit Varint]
|
|-
! VarLong
| Varies
| 
| Like VarInt but for java longs
|- class="row9"
! class="col0 centeralign" | metadata
| class="col1 centeralign" | Varies
| class="col2" | See [[Entities#Entity_Metadata_Format|this]]
| class="Col3" | 
|- 
! class="centeralign" | Slot Data
| class="centeralign" | Varies
| See [[Slot_Data|slot data]]
|
|-
! Position 
| 8
| 
| See below
|-
! UUID
| 16
|
| Encoded as two longs this.writeLong(uuid.getMostSignificantBits()); this.writeLong(uuid.getLeastSignificantBits());
|}

=== Position ===

64-bit long split in to three parts

x: 24 MSBs
z: 24 LSBs
y: 12 bits between them

Encoded as followed:

  ((x & 0x3FFFFFF) << 38) | ((y & 0xFFF) << 26) | (z & 0x3FFFFFF)
 

And decoded as:

  long val; // Encoded value
  x = val >> 38;
  y = (val >> 26) & 0xFFF
  z = val << 38 >> 38

=== Fixed-point numbers ===

Some fields may be stored as [https://en.wikipedia.org/wiki/Fixed-point_arithmetic fixed-point numbers], where a certain number of bits represents the signed integer part (number to the left of the decimal point) and the rest represents the fractional part (to the right). Floating points (float and double), in contrast, keep the number itself (mantissa) in one chunk, while the location of the decimal point (exponent) is stored beside it. 

Essentially, while fixed-point numbers have lower range than floating points, their fractional precision is greater for higher values. This makes them ideal for representing global coordinates of an entity in Minecraft, as it's more important to store the integer part accurately than position them more precisely within a single block (or meter). 

Coordinates are often represented as a 32-bit integer, where 5 of the least-significant bits are dedicated to the fractional part, and the rest store the integer part.

Java lacks support for fractional integers directly, but you can represent them as integers. To convert from a double to this integer representation, use the following formulas:
  abs_int = (int)double * 32;
And back again:

  double = (double)abs_int / 32;

[[Category:Protocol Details]]
[[Category:Minecraft Modern]]
