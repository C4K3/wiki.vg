Minecraft 1.6 introduced a new authentication scheme called '''Yggdrasil''' which completely replaces the [[Legacy Authentication|previous authentication system]]. Mojang's other game, Scrolls, uses this method of authentication as well. Mojang has said that [https://twitter.com/KrisJelbring/status/453573406341206016 this authentication system should be used by everyone for custom logins], but [https://twitter.com/KrisJelbring/status/461390585086361600 credentials should never be collected from users].

== Request format ==

All requests to Yggdrasil are made to the following server:

 https://authserver.mojang.com

Further, they are expected to fulfill the following rules:

* Are <code>POST</code> requests
* Have the <code>Content-Type</code> header set to <code>application/json</code>
* Contain a [[wikipedia:JSON|JSON]]-encoded dictionary as payload

If a request was successful the server will respond with:

* Status code <code>200</code>
* A [[wikipedia:JSON|JSON]]-encoded dictionary according to the specifications below

If however a request fails, the server will respond with:

* An appropriate, non-200 [[wikipedia:List of HTTP status codes|HTTP status code]]
* A [[wikipedia:JSON|JSON]]-encoded dictionary following this format:

<syntaxhighlight lang="javascript">
{
    "error": "Short description of the error",
    "errorMessage": "Longer description which can be shown to the user",
    "cause": "Cause of the error" // optional
}
</syntaxhighlight>

== Errors ==

These are some of the errors that can be encountered:

{| class="wikitable"
 |-
 ! Error
 ! Cause
 ! Error message
 ! Notes
 |-
 | <code>Method Not Allowed</code>
 |
 | The method specified in the request is not allowed for the resource identified by the request URI
 | Something other than a POST request was received.
 |-
 | <code>Not Found</code>
 |
 | The server has not found anything matching the request URI
 | Non-existing endpoint was called.
 |-
 | <code>ForbiddenOperationException</code>
 | <code>UserMigratedException</code>
 | Invalid credentials. Account migrated, use e-mail as username.
 | 
 |-
 | <code>ForbiddenOperationException</code>
 | 
 | Invalid credentials. Invalid username or password.
 | 
 |-
 | <code>ForbiddenOperationException</code>
 | 
 | Invalid credentials.
 | Too many login attempts with this username recently (see <code>/authenticate</code>). Note that username and password may still be valid!
 |-
 | <code>ForbiddenOperationException</code>
 | 
 | Invalid token.
 | <code>accessToken</code> was invalid.
 |-
 | <code>IllegalArgumentException</code>
 | 
 | Access token already has a profile assigned.
 | Selecting profiles isn't implemented yet.
 |-
 | <code>IllegalArgumentException</code>
 | 
 | credentials is null
 | Username/password was not submitted.
 |-
 | <code>Unsupported Media Type</code>
 | 
 | The server is refusing to service the request because the entity of the request is in a format not supported by the requested resource for the requested method
 | Data was not submitted as application/json
 |}

== Authenticate ==

Authenticates a user using their password.

=== Endpoint ===

 /authenticate

=== Payload ===

<syntaxhighlight lang="javascript">
{
    "agent": {                              // defaults to Minecraft
        "name": "Minecraft",                // For Mojang's other game Scrolls, "Scrolls" should be used
        "version": 1                        // This number might be increased
                                            // by the vanilla client in the future
    },
    "username": "mojang account name",      // Can be an email address or player name for
                                            // unmigrated accounts
    "password": "mojang account password",
    "clientToken": "client identifier",     // optional
    "requestUser": true                     // optional; default: false; true adds the user object to the response
}
</syntaxhighlight>

The <code>clientToken</code> should be a randomly generated identifier and must be identical for each request. The vanilla launcher generates a random (version 4) UUID on first run and saves it, reusing it for every subsequent request. In case it is omitted the server will generate a random token based on Java's [http://docs.oracle.com/javase/7/docs/api/java/util/UUID.html#toString() <code>UUID.toString()</code>] which should then be stored by the client. This will however also invalidate all previously acquired <code>accessToken</code>s for this user across all clients.

=== Response ===

<syntaxhighlight lang="javascript">
{
    "accessToken": "random access token",      // hexadecimal
    "clientToken": "client identifier",        // identical to the one received
    "availableProfiles": [                     // only present if the agent field was received
        {
            "id": "profile identifier",        // hexadecimal
            "name": "player name",
            "legacy": true or false            // In practice, this field only appears in the response if true. Default to false.
        }
    ],
    "selectedProfile": {                       // only present if the agent field was received
        "id": "uuid without dashes",
        "name": "player name",
        "legacy": true or false
    },
    "user": {                                  // only present if requestUser was true in the request payload
        "id": "user identifier",               // hexadecimal
        "properties": [
            {
                "name": "preferredLanguage",   // might not be present for all accounts
                "value": "en"                  // ISO 639-1?
            },
            {
                "name": "twitch_access_token", // only present if a twitch account is associated (see https://account.mojang.com/me/settings)
                "value": "twitch oauth token"  // OAuth 2.0 Token; alphanumerical; e.g. https://api.twitch.tv/kraken?oauth_token=[...]
                                               // the Twitch API is documented here: https://github.com/justintv/Twitch-API
            }
        ]
    }
}
</syntaxhighlight>

'''Note:''' If a user wishes to stay logged in on their computer you are strongly advised to store the received <code>accessToken</code> instead of the password itself.

Currently each account will only have one single profile, multiple profiles per account are however planned in the future. If a user attempts to log into a valid Mojang account with no attached Minecraft license, the authentication will be successful, but the response will not contain a <code>selectedProfile</code> field, and the <code>availableProfiles</code> array will be empty.

Some instances in the wild have been observed of Mojang returning a flat <code>null</code> for failed refresh attempts against legacy accounts. It's not clear what the actual error tied to the null response is and it is extremely rare, but implementations should be wary of null output from the response.

This endpoint is severely rate-limited: multiple <code>/authenticate</code> requests for the same account in a short amount of time (think 3 requests in a few seconds), even with the correct password, will eventually lead to an <code>Invalid credentials.</code> response. This error clears up a few seconds later.

== Refresh ==

Refreshes a valid <code>accessToken</code>. It can be used to keep a user logged in between gaming sessions and is preferred over storing the user's password in a file (see [[lastlogin]]). 

=== Endpoint ===

 /refresh

=== Payload ===
<syntaxhighlight lang="javascript">
{
    "accessToken": "valid accessToken",
    "clientToken": "client identifier",  // This needs to be identical to the one used
                                         // to obtain the accessToken in the first place
    "selectedProfile": {                 // optional; sending it will result in an error
        "id": "profile identifier",      // hexadecimal
        "name": "player name"
    },
    "requestUser": true                  // optional; default: false; true adds the user object to the response
}
</syntaxhighlight>

Note: The provided <code>accessToken</code> gets invalidated.

=== Response ===

<syntaxhighlight lang="javascript">
{
    "accessToken": "random access token",      // hexadecimal
    "clientToken": "client identifier",        // identical to the one received
    "selectedProfile": {
        "id": "profile identifier",            // hexadecimal
        "name": "player name"
    },
    "user": {                                  // only present if requestUser was true in the request payload
        "id": "user identifier",               // hexadecimal
        "properties": [
            {
                "name": "preferredLanguage",   // might not be present for all accounts
                "value": "en"                  // ISO 639-1?
            },
            {
                "name": "twitch_access_token", // only present if a twitch account is associated (see https://account.mojang.com/me/settings)
                "value": "twitch oauth token"  // OAuth 2.0 Token; alphanumerical; e.g. https://api.twitch.tv/kraken?oauth_token=[...]
                                               // the Twitch API is documented here: https://github.com/justintv/Twitch-API
            }
        ]
    }
}
</syntaxhighlight>

== Validate ==

Checks if an <code>accessToken</code> is usable for authentication with a Minecraft server. The Minecraft Launcher (as of version 1.6.13) calls this endpoint on startup to verify that its saved token is still usable, and calls <code>/refresh</code> if this returns an error.

Note that an <code>accessToken</code> may be unusable for authentication with a Minecraft server, but still be good enough for <code>/refresh</code>. This mainly happens when one has used another client (e.g. played Minecraft on another PC with the same account). It seems only the most recently obtained <code>accessToken</code> for a given account can reliably be used for authentication (the next-to-last token also seems to remain valid, but don't rely on it).

<code>/validate</code> may be called with or without a <code>clientToken</code>. If a <code>clientToken</code> is provided, it should match the one used to obtain the <code>accessToken</code>. The Minecraft Launcher does send a <code>clientToken</code> to <code>/validate</code>.

=== Endpoint ===

 /validate

=== Payload ===

<syntaxhighlight lang="javascript">
{
    "accessToken": "valid accessToken",
    "clientToken": "associated clientToken" // optional, see above
}
</syntaxhighlight>

=== Response ===

Returns an empty payload (<code>204 No Content</code>) if successful, an error JSON with status <code>403 Forbidden</code> otherwise.

== Signout ==

Invalidates <code>accessToken</code>s using an account's username and password.

=== Endpoint ===

 /signout

=== Payload ===

<syntaxhighlight lang="javascript">
{
    "username": "mojang account name",
    "password": "mojang account password"
}
</syntaxhighlight>

=== Response ===

Returns an empty payload if successful.

== Invalidate ==

Invalidates <code>accessToken</code>s using a client/access token pair.

=== Endpoint ===

 /invalidate

=== Payload ===

<syntaxhighlight lang="javascript">
{
    "accessToken": "valid accessToken",
    "clientToken": "client identifier"   // This needs to be identical to the one used
                                         // to obtain the accessToken in the first place
}
</syntaxhighlight>

=== Response ===

Returns an empty payload if successful.

== Joining a Server ==

See [[Protocol Encryption#Authentication]]

[[Category:Protocol Details]]
[[Category:Minecraft Modern]]
