The latest version of the Minecraft game uses a new, more efficient (but still poor) format for storing a worlds chunk data, based on work by Scaevolous.

== Background & Reasoning ==
  
Prior to this system, each chunk (a 16x16x128 area of a level) was contained within its own file on disk, two folders down. The first folder represented the <code>X</code> region, and the second the <code>Y</code> region. This (very obviously) has several issues associated with it, mainly:

* Excessive filesystem activity,
* Poor fragmentation,
* Unneeded filesystem overhead (a 90-byte compressed chunk of mostly dirt and air will still consume at a minimum one sector, generally more),
* Generates large enough directory trees on large worlds to crash the Windows Explorer,
* A large multiplayer world would eventually run out of handles (by default, only 1024 handles can be opened by a single process), causing the server to stall, crash, or otherwise fail (the particular behaviour has changed between versions)
 
To improve performance, Scaevolous created an unofficial mod called McRegion. This mod groups chunks into ''regions'', each of which contains a group of ''chunks'' 32 by 32. In theory, this improves a few things:
 
* Reduces filesystem activity &amp; overhead considerably,
* Improves fragmentation (not directly, but the OS or underlying drive can intelligently improve it),
* Far, far fewer handles need to be open at any given time, allowing more of the level to be loaded at any one time.
* Reduces the number of files created considerably (no more crashing Explorer)
 
To define some terminology,
           
{| class="wikitable"
|-
! Chunk 
| A single section of the level that is 16 by 16 blocks, and 128 blocks high. 
|-
! Region 
| A single grouping of ''chunks'' in a 32 by 32 area 
|-
! Level 
| A (realistically, but not technically) unlimited collection of ''chunks'' stored in ''regions'' that make up a single playable world. 
|}  
== Specification ==
   
=== File Names ===
  
In the official client and server, each region is stored within the folder <code>region</code> within the level folder. The naming scheme for region files is very simple. For example, given the filename <code>r.8.20.mcr</code>, <code>r</code> is a meaningless prefix found on all region files, <code>8</code> is the <code>X</code> coordinate of the region, and <code>20</code> is the <code>Z</code> coordinate of the region.
 
The region <code>X</code> and <code>Z</code> can be found simply by dividing the chunks <code>X</code> or <code>Z</code> by 32, and then [http://en.wikipedia.org/wiki/Floor_and_ceiling_functions flooring] the result. Here&#039;s an example in python, where given a chunk at &lt;81, -39&gt;, the region filename can be found:

<pre>&gt;&gt;&gt; import math &gt;&gt;&gt; region_xz = lambda x,z: &#40;math.floor&#40;x / 32&#41;, math.floor&#40;z / 32&#41;&#41; &gt;&gt;&gt; region_xz&#40;81,-39&#41; &#40;2.0, -2.0&#41;
</pre>
 
So, this chunk would reside in <code>r.2.-2.mcr</code>.

=== Structure ===
  
Every region file begins with two 4KiB tables (each compose of 1024 4-byte integers), with the first table containing the location of each chunk, and the second table the last-modified timestamp of that chunk.

==== Location Table ====
  
The location table is composed of 1024 entries, each 4 bytes long. The first three bytes indicate the offset in the file where the chunk may be found, and the last byte is the size of the file. When multiplied by <code>4096</code>, this gives you the exact start of the chunk in bytes, and its end in bytes. If you know the <code>X</code> and <code>Z</code> of the chunk you&#039;re looking for, you can find its location entry using the formula: <code>((x % 32) + (z % 32) * 32) * 4</code>. If the offset and size are both <code>0</code>, then the chunk at that location hasn&#039;t been generated yet.

As an example, this is the location entry for the first chunk in a region:
           
{| class="wikitable"
|-
| 
!  Offset  (3 bytes) 
!  Size  (1 byte)
|-
! Decoded 
| <code>2</code> 
| <code>1</code> 
|-
! On Disk (in hex) 
| <code>00</code> 
| <code>00</code> 
| <code>02</code> 
| <code>01</code> 
|} 
Here&#039;s an example in Python to decode a location entry:
 
<pre>def chunk_location&#40;l&#41;:
    &quot;&quot;&quot;
    Returns the offset (in bytes) and size (in bytes) of the chuck for
    the given location.
    &quot;&quot;&quot;
    offset = &#40;&#40;l &gt;&gt; 8&#41; &amp; 0xFF&#41; + &#40;&#40;l &gt;&gt; 16&#41; &amp; 0xFF&#41; + &#40;&#40;l &gt;&gt; 32&#41; &amp; 0xFF&#41;
    size = l &amp; 0xFF
 
    return &#40;offset * 4096, size * 4096&#41;
</pre>
  
==== Timestamp Table ====
  
The timestamp table is composed of 1024 timestamps, each a 4-byte integer. This is the time that the chunk was last modified, and is in the same order as the location table. Thus, the chunk whose location was at <code>location_table[15]</code> has a timestamp at <code>timestamp_table[15]</code>.
  
==== Chunk Header ====
  
Each chunk has an additional 5-byte header, followed by the actual chunk which is stored as [[NBT]].
           
{| class="wikitable"
|-
| 
!  Length (in bytes)  
!  Compression Scheme  
|-
! Decoded 
| <code>528</code> 
| <code>2</code> 
|-
! On disk (in hex) 
| <code>00 00 02 10</code> 
| <code>02</code> 
|} 
There are two possible values for the compression scheme. If it is a <code>1</code>, the following chunk is compressed using [[gzip]]. If it&#039;s a <code>2</code>, the following chunk is compressed with [[zlib]]. In practice, you will only ever encounter chunks compressed using zlib.
